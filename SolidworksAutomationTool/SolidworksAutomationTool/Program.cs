// See https://aka.ms/new-console-template for more information

using SolidWorks.Interop.sldworks;
using SolidWorks.Interop.swconst;
using SolidworksAutomationTool;
using static SolidworksAutomationTool.ScaffoldFunctions;
using ShellProgressBar;
using System.Diagnostics;

/* Define some parameters here. These parameters should be configurable in the GUI */
// NOTE: Base parameters
// param: Save Part flag in directory
const bool SavePart = true;
// param: specify the project. e.g. MUST
const string project = "Spec-s5";
// param: chamfer length of a chamfered triangle
const double chamferLength = 10.5e-3;               // in meters
// param: pin hole diameter
const double pinHoleDiameter = 2.5e-3;              // in meters
// param: pin hole depth
const double pinHoleDepth = 3.5e-3;                  // in meters
// param: inter pin hole distance 
const double interPinHoleDistance = 64.952e-3;          // in meters
// param: fillet radius in full triangle
const double filletRadiusFullTriangle = 2.5e-3;     // in meters 
// param: bestFitSphereRadius.
const double bestFitSphereRadius = 12657e-3;      // in meters
// param: focal plane thickness
const double outerRimHeight = 150e-3;                     // in meters
// param: distance between the bottom surface of the plate and support faces of modules
const double bottom2SupportFacesDistance = 30e-3;       // in meters
// param: distance between the support surface to top surface definition
const double supportToTopSurfaceDistance = outerRimHeight - bottom2SupportFacesDistance;         // in meters
// param: create horizontal line (for flat bottom surface). Need a better name here
const double bottomSurfaceRadius = 480e-3;
// param: side length of the equilateral triangle (full triangle)
const double equilateralTriangleSideLength = 76.4e-3;

// add variables to the solidworks global variable equation table. If later fine tuning of some parameters is needed, the user can do so in solidworks' GUI
Dictionary<string, double> solidworksGlobalVariables = new()
{
    { nameof(chamferLength), chamferLength },
    { nameof(pinHoleDiameter), pinHoleDiameter },
    { nameof(pinHoleDepth), pinHoleDepth },
    { nameof(interPinHoleDistance), interPinHoleDistance },
    { nameof(filletRadiusFullTriangle), filletRadiusFullTriangle },
    { nameof(bestFitSphereRadius), bestFitSphereRadius },
    { nameof(outerRimHeight), outerRimHeight },
    { nameof(supportToTopSurfaceDistance), supportToTopSurfaceDistance },
    { nameof(bottom2SupportFacesDistance), bottom2SupportFacesDistance },
    { nameof(bottomSurfaceRadius), bottomSurfaceRadius },
    { nameof(equilateralTriangleSideLength), equilateralTriangleSideLength },
};

Console.WriteLine("Welcome to the LASTRO Solidworks Automation Tool!");

// import the point cloud (the grid text file generated by the python script)
/* Uncomment the Console.ReadLine() to restore normal path input. Currently they are commented out for debug purpose */
Console.WriteLine("Please enter the path of the FRONT grid point cloud txt file");
string frontGridPointCloudFilePath = Console.ReadLine();
// string frontGridPointCloudFilePath = Path.GetFullPath(@$"..\..\Results_examples\Grid_examples\{project}\front.txt"); // For debug use.

Console.WriteLine("Reading front grid point cloud file ...");
PointCloud frontGridPointCloud = new();
frontGridPointCloud.ReadPointCloudFromTxt(frontGridPointCloudFilePath, Units.Millimeter);
Console.WriteLine("Completed reading point cloud file");

Console.WriteLine("Please enter the path of the BACK grid point cloud txt file");
string backGridPointCloudFilePath = Console.ReadLine();
// string backGridPointCloudFilePath = Path.GetFullPath(@$"..\..\Results_examples\Grid_examples\{project}\back.txt"); // For debug use

Console.WriteLine("Reading back grid point cloud file ...");
PointCloud backGridPointCloud = new();
backGridPointCloud.ReadPointCloudFromTxt(backGridPointCloudFilePath, Units.Millimeter);
Console.WriteLine("Completed reading point cloud file");

if ( frontGridPointCloud.point3Ds.Count != backGridPointCloud.point3Ds.Count )
{
    Console.WriteLine("WARNING: the number of points on the front and back grid are not the same. Is this intentional?");
}

// remove the offset in Z direction with the best-fit sphere's radius. Otherwise the points are placed at a super far place
Console.WriteLine("Removing offsets in Z axis for all points ...");

// Using the add operation because the z coordinates in the point clouds are negative. We want to offset them to close to zero
// foreach ((Point3D frontPoint, Point3D backPoint) in frontGridPointCloud.point3Ds.Zip(backGridPointCloud.point3Ds))
// {
//     frontPoint.z += bestFitSphereRadius;
//     backPoint.z += bestFitSphereRadius;
// }

//  Please give the directory where the created models would be placed
//  string modelOutputDirectory = Console.ReadLine();
//  Otherwise models will be stored in a folder on Desktop
string currentTime = DateTime.Now.ToString("dd-MM-yyyy_HH-mm");
// string desktopPath = System.Environment.GetFolderPath(System.Environment.SpecialFolder.Desktop);
// string modelOutputDirectory = Path.Join(desktopPath, $"{project}_Models_{currentTime}");
string modelOutputDirectory = Path.GetFullPath(@$"..\..\Results\{project}\Focal_plates");


// create the directory to store models. Since we timestamp the output directory, there is almost chance to have another directory with the same name
if (!Path.Exists(modelOutputDirectory) & SavePart)
{
    DirectoryInfo _ = Directory.CreateDirectory(modelOutputDirectory);
}


//Console.WriteLine("\nFront grid point cloud with z-axis offset removed: ");
// DEBUG use: check if the points are read in correctly
//frontGridPointCloud.PrintPoint3Ds();
//frontGridPointCloud.PrintModuleOrientations();

//Console.WriteLine("\nBack grid point cloud with z-axis offset removed: ");
// DEBUG use: check if the points are read in correctly
//backGridPointCloud.PrintPoint3Ds();
//backGridPointCloud.PrintModuleOrientations();

Console.WriteLine("Starting SolidWorks Application ...");

// Solidworks related variable definitions
SldWorks? solidworksApp;
ModelDoc2 modulePart;
ModelView modelView;
// get solidworks and start it
const string solidWorkAppID = "SldWorks.Application";
solidworksApp = Activator.CreateInstance(Type.GetTypeFromProgID(solidWorkAppID)) as SldWorks;

if (solidworksApp == null)
{
    Console.WriteLine("SolidWorks could not be started. Exiting program now");
    return;
}

solidworksApp.Visible = true;
Console.WriteLine("Please wait a bit. SolidWorks should appear. If not, there is an error starting solidworks");

/* Start modeling the robot holder in the focal plane */
//PromptAndWait("Press any key to create the robot-holder from the point clouds");
Console.WriteLine("Creating extrusion axes from point clouds ...");

// create a part
modulePart = solidworksApp.INewDocument2( solidworksApp.GetUserPreferenceStringValue((int)swUserPreferenceStringValue_e.swDefaultTemplatePart), 0, 0, 0);

// test adding global variables - seems fine
foreach (KeyValuePair<string, double> variableNameValue in solidworksGlobalVariables)
{
    CreateGlobalVariableInAllConfigs(ref modulePart, variableNameValue.Key, variableNameValue.Value);
}

// Get a handle to the FRONT, TOP, RIGHT planes
BasicReferenceGeometry basicRefGeometry = GetBasicReferenceGeometry(ref modulePart);

// Create a 3D sketch to put point clouds on 
modulePart.SketchManager.Insert3DSketch(true);

// set the view to isometric. The empty string tells solidworks to use the view indicated by the swStandardViews_e enum.
modulePart.ShowNamedView2("", (int)swStandardViews_e.swIsometricView);

// disable user input box when adding dimensions
DisableInputDimensionByUser(ref solidworksApp);

// disable view refreshing until points are created
modelView =(ModelView)modulePart.GetFirstModelView();
modelView.EnableGraphicsUpdate = false;
modulePart.SketchManager.AddToDB = true;

// try disabling feature tree updates to gain performance
modulePart.FeatureManager.EnableFeatureTree = false;
// EnableGraphicsUpdate affects whether to refresh the model view during a selection, such as IEntity::Select4 or IFeature::Select2.

// try to allocate space for front sketchpoints and back sketchpoints
List<SketchPoint> frontSketchPointList = new(frontGridPointCloud.point3Ds.Count);
List<SketchPoint> backSketchPointList = new(backGridPointCloud.point3Ds.Count);
List<SketchSegment> extrusionAxisList = new(frontSketchPointList.Count);

// default progress bar styling option
ProgressBarOptions progressBarOptions = new()
{
    ProgressCharacter = '#',
    ProgressBarOnBottom = true,
    BackgroundColor = ConsoleColor.DarkGray,
    DisplayTimeInRealTime = false
};

using ( ProgressBar createExtrusionAxesProgressBar = new(frontGridPointCloud.point3Ds.Count, "Creating extrusion axes", progressBarOptions))
{
    // Try iterating through two point clouds at the same time
    foreach ((Point3D frontPoint, Point3D backPoint) in frontGridPointCloud.point3Ds.Zip(backGridPointCloud.point3Ds))
    {
        // create top and bottom points
        frontSketchPointList.Add(modulePart.SketchManager.CreatePoint(frontPoint.x, frontPoint.y, frontPoint.z));
        backSketchPointList.Add(modulePart.SketchManager.CreatePoint(backPoint.x, backPoint.y, backPoint.z));

        // create axis of extrusion as construction lines
        extrusionAxisList.Add(modulePart.SketchManager.CreateLine(frontPoint.x, frontPoint.y, frontPoint.z, backPoint.x, backPoint.y, backPoint.z));
        // using fancy but convenient index-from-end operator (^), which is available in C# 8.0 and later, to get the last element in a list.
        extrusionAxisList[^1].ConstructionGeometry = true;

        // update the progress bar
        createExtrusionAxesProgressBar.Tick();
    }
}

Console.WriteLine("Extrusion axes placement completed");

// EnableGraphicsUpdate affects whether to refresh the model view during a selection, such as IEntity::Select4 or IFeature::Select2.
modelView.EnableGraphicsUpdate = true;

// Sometimes the camera is not pointing toward the part. So repoint the camera to the part.
modulePart.ViewZoomtofit2();

// Close the 3D sketch. Calling Insert3DSketch will either Inserts a new 3D sketch in a model or closes the active sketch.
// Since Insert3DSketch was called once already, calling it twice will close the 3D sketch
modulePart.SketchManager.Insert3DSketch(true);

// magic clear selection method
ClearSelection(ref modulePart);

// create another 3D sketch so that the extrusion axes are untouched
modulePart.SketchManager.Insert3DSketch(true);
ClearSelection(ref modulePart);

//PromptAndWait("Press any key to create small segments");
Console.WriteLine("Creating small segments ...");

// According to solidworks api, we need to define a SelectData object and pass it into each selection call.
SelectionMgr swSelectionManager = (SelectionMgr)modulePart.SelectionManager;
SelectData swSelectData = swSelectionManager.CreateSelectData();

// Keep a list of the points that defines the positions of the support surfaces
List<SketchPoint> supportSurfaceMarkerPointList = new(frontSketchPointList.Count);

// disable graphics update to boost performance
modelView.EnableGraphicsUpdate = false;

// Create the support surface markers from the top surface
using (ProgressBar createSmallSegmentsProgressBar = new(backSketchPointList.Count, "Creating support surface markers", progressBarOptions))
{
    foreach ((SketchPoint frontSketchPoint, SketchPoint backSketchPoint, SketchSegment extrusionAxis) in frontSketchPointList.Zip(backSketchPointList, extrusionAxisList))
    {
        // first create a small sketch point at the middle of an extrusion axis
        SketchPoint smallSegmentSketchPoint = modulePart.SketchManager.CreatePoint((frontSketchPoint.X + backSketchPoint.X) / 2,
                                                (frontSketchPoint.Y + backSketchPoint.Y) / 2,
                                                (frontSketchPoint.Z + backSketchPoint.Z) / 2);

        // constraint the point to be on coincide with the extrusion axis. Assuming the smallSegmentSketchPoint is already selected after creation
        extrusionAxis.Select4(true, swSelectData);
        MakeSelectedCoincide(ref modulePart);
        // clear previous selections, so that no unintentional selection
        ClearSelection(ref modulePart);

        // add a length dimension to the small segment
        frontSketchPoint.Select4(true, swSelectData);
        smallSegmentSketchPoint.Select4(true, swSelectData);

        // Using global variable to dimension
        AddDimensionToSelectedWithGlobalVariable(ref modulePart, nameof(supportToTopSurfaceDistance), frontSketchPoint.X, frontSketchPoint.Y, frontSketchPoint.Z);

        ClearSelection(ref modulePart);
        // save the support surface marker point to the list. It will be used in the later support surface extrusion
        supportSurfaceMarkerPointList.Add(smallSegmentSketchPoint);

        // update progress bar
        createSmallSegmentsProgressBar.Tick();
    }
}
// Evaluate all the expressions in the global equation table
modulePart.GetEquationMgr().EvaluateAll();

Console.WriteLine("Support surface markers are created");
// enbale user input box for dimensions
EnableInputDimensionByUser(ref solidworksApp);

// restore settings to make solidworks operate as normal
modulePart.SketchManager.AddToDB = false;
modelView.EnableGraphicsUpdate = true;
modulePart.FeatureManager.EnableFeatureTree = true;

// Close the 3D sketch with support surface markers
modulePart.SketchManager.Insert3DSketch(true);
ClearSelection(ref modulePart);
ZoomToFit(ref modulePart);

// SAVE model. In case of error, you will see error message in the console
// SaveModel(SavePart, ref modulePart, Path.Join(modelOutputDirectory, "ExtrusionAxes"));

modulePart.SketchManager.AddToDB = true;

//PromptAndWait("Press any key to revolve a pizza slice (1/6 of a pizza)");
Console.WriteLine("Revolving a pizza slice ...");

// define variables needed for pizza creation
double arcAngle = DegreeToRadian(15);

// Solidworks wants points to be defined in the local cartesian coordinate frame inside a sketch
Point3D arcCenterPoint = new(0, -bestFitSphereRadius, 0);
Point3D arcStartPoint = new(0, 0, 0);
Point3D arcEndPoint = new(bestFitSphereRadius * Math.Sin(arcAngle), -bestFitSphereRadius * (1 - Math.Cos(arcAngle)), 0);

// select top reference plane
basicRefGeometry.topPlane.Select2(false, -1);
// create arc to form the curved top surface
modulePart.SketchManager.InsertSketch(true);

// TODO: find a good way to describe which line is which
DisableInputDimensionByUser(ref solidworksApp);

SketchArc arc = (SketchArc)modulePart.SketchManager.CreateArc(arcCenterPoint.x, arcCenterPoint.y, arcCenterPoint.z,
                                    arcStartPoint.x, arcStartPoint.y, arcStartPoint.z,
                                    arcEndPoint.x, arcEndPoint.y, arcEndPoint.z,
                                    -1);    // +1 : Go from the start point to the end point in a counter-clockwise direction
ClearSelection(ref modulePart);

// try to constraint the arc's starting point to the origin
SketchPoint arcStartSketchPoint = (SketchPoint)arc.GetStartPoint2();
arcStartSketchPoint.Select4(true, swSelectData);
basicRefGeometry.origin.Select4(false, swSelectData);
MakeSelectedCoincide(ref modulePart);
ClearSelection(ref modulePart);

// Dimension the arc
((SketchSegment)arc).Select4(true, swSelectData);
AddDimensionToSelectedWithGlobalVariable(ref modulePart, nameof(bestFitSphereRadius), 
                                                            arcStartPoint.x / 2.0 + arcEndPoint.x / 2.0,
                                                            arcStartPoint.y / 2.0,
                                                            arcStartPoint.z / 2.0 + arcEndPoint.z / 2.0);

ClearSelection(ref modulePart);

// create vertical line aka the revolution axis
SketchLine revolutionAxisVerticalLine = (SketchLine)modulePart.SketchManager.CreateLine(arcStartPoint.x, arcStartPoint.y, arcStartPoint.z, 
                                                                            arcStartPoint.x, 180e-3, 0);
MakeSelectedLineVertical(ref modulePart);
ClearSelection(ref modulePart);
// try to select the origin and set the revolution axis to be coincident with it
basicRefGeometry.origin.Select4(false, swSelectData);
SketchPoint revolutionAxisVerticalLineStartPoint = (SketchPoint)revolutionAxisVerticalLine.GetStartPoint2();
revolutionAxisVerticalLineStartPoint.Select4(true, swSelectData);
MakeSelectedCoincide(ref modulePart);

ClearSelection(ref modulePart);

// coincide the center point of the arc to the revolution axis
SketchPoint arcCenterSketchPoint = (SketchPoint)arc.GetCenterPoint2();
arcCenterSketchPoint.Select4(true, swSelectData);
((SketchSegment)revolutionAxisVerticalLine).Select4(true, swSelectData);
MakeSelectedCoincide(ref modulePart);
ClearSelection(ref modulePart);

SketchPoint revolutionAxisVerticalLineEndPoint = (SketchPoint)revolutionAxisVerticalLine.GetEndPoint2();
SketchLine horizontalLine = (SketchLine)modulePart.SketchManager.CreateLine(revolutionAxisVerticalLineEndPoint.X, revolutionAxisVerticalLineEndPoint.Y, revolutionAxisVerticalLineEndPoint.Z,
                                                                            bottomSurfaceRadius, revolutionAxisVerticalLineEndPoint.Y, 0);
MakeSelectedLineHorizontal(ref modulePart);

// add dimension constraint to the horizontal line
AddDimensionToSelectedWithGlobalVariable(   ref modulePart, 
                                            nameof(bottomSurfaceRadius),
                                            revolutionAxisVerticalLineEndPoint.X,
                                            revolutionAxisVerticalLineEndPoint.Y,
                                            revolutionAxisVerticalLineEndPoint.Z );

ClearSelection(ref modulePart);
// create vertical line (outer rim of the boarder) connecting the top line 
SketchPoint bottomSurfaceTopRightPoint = (SketchPoint)horizontalLine.GetEndPoint2();

SketchLine revolutionAxisVerticalLineToArc = (SketchLine)modulePart.SketchManager.CreateLine(bottomSurfaceTopRightPoint.X, bottomSurfaceTopRightPoint.Y, bottomSurfaceTopRightPoint.Z, 
                                                                                bottomSurfaceTopRightPoint.X, -outerRimHeight, 0);
MakeSelectedLineVertical(ref modulePart);
ClearSelection(ref modulePart);

// make vertical line coincide with the arc
SketchPoint revolutionAxisVerticalLineToArcEndPoint = (SketchPoint)revolutionAxisVerticalLineToArc.GetEndPoint2();
revolutionAxisVerticalLineToArcEndPoint.Select4(true, swSelectData);
((SketchSegment)arc).Select4(true, swSelectData);
MakeSelectedCoincide(ref modulePart);
ClearSelection(ref modulePart);

// add dimension to outer rim height
((SketchSegment)revolutionAxisVerticalLineToArc).Select4(true, swSelectData);

AddDimensionToSelectedWithGlobalVariable(   ref modulePart, 
                                            nameof(outerRimHeight), 
                                            bottomSurfaceTopRightPoint.X, 
                                            bottomSurfaceTopRightPoint.Y, 
                                            bottomSurfaceTopRightPoint.Z);
//AddDimensionToSelected(ref modulePart, outerRimHeight, bottomSurfaceTopRightPoint);
ClearSelection(ref modulePart);

modulePart.SketchManager.AddToDB = false;

// trim the extra arc. This is a preparation step of creating a pizza slice revolution
((SketchSegment)arc).Select4(true, swSelectData);
bool trimSuccess = modulePart.SketchManager.SketchTrim((int)swSketchTrimChoice_e.swSketchTrimClosest, arcEndPoint.x, arcEndPoint.y, arcEndPoint.z);
ClearSelection(ref modulePart);

// get the current sketch's name
string pizzaSketchName = ((Feature)modulePart.SketchManager.ActiveSketch).Name;

// quit editing sketch the pizza slice sketch
modulePart.SketchManager.InsertSketch(true);
ClearSelection(ref modulePart);

/* Create the first pizza slice */
// select the sketch to revolve with
SelectSketch(ref modulePart, pizzaSketchName, true);

// select the axis to revolve. According to API doc, we must select with a specific mark
swSelectData.Mark = 4;
((SketchSegment)revolutionAxisVerticalLine).Select4(true, swSelectData);
// Revolve the first pizza slice
// TODO: check if it's necessary to create a wrapper function for the feature revolve function. The official api takes too many parameters
Feature pizzaSlice = modulePart.FeatureManager.FeatureRevolve2(true, true, false, false, true, false, 
                                                0, 0, DegreeToRadian(60), 0, false, false, 0.01, 0.01, 0, 0, 0, true, true, true);

ClearSelection(ref modulePart);
Console.WriteLine("1/6 of the pizza created");
ZoomToFit(ref modulePart);


// enbale user input box for dimensions
EnableInputDimensionByUser(ref solidworksApp);

/* Extrude triangles on the pizza slice
 * Steps:
 * 1. create points that are both on the bottom plane and the extrusion axes    - Done
 * 2. create reference planes by using "normal and point" method                - Done
 * 3. start sketches on those planes and draw triangles on sketches             - Done
 * 4. extrude triangles                                                         - Done
 */
Console.WriteLine("Extruding modules ...");
// NOTE: Bottom plane creation
// First define the bottom plane, by creating a parallel plane w.r.t the front plane
double bottomToFrontPlaneDistance = ((SketchSegment)revolutionAxisVerticalLine).GetLength();

// Select the front plane in a language-neutral way
basicRefGeometry.frontPlane.Select2(false, 0);

// A trick to flip the offset orientation when creating a ref plane: https://stackoverflow.com/questions/71885722/how-to-create-a-flip-offset-reference-plane-with-solidworks-vba-api
RefPlane bottomPlane = (RefPlane)modulePart.FeatureManager.InsertRefPlane(  (int)swRefPlaneReferenceConstraints_e.swRefPlaneReferenceConstraint_Distance
                                                                            + (int)swRefPlaneReferenceConstraints_e.swRefPlaneReferenceConstraint_OptionFlip, 
                                                                            bottomToFrontPlaneDistance,
                                                                             0, 0, 0, 0);
((Feature)bottomPlane).Name = "Bottom Plane";

// quick test to see if a point can be created on the bottom surface
// Create a sketch to add points on
modulePart.Insert3DSketch();
// for speed improvements
modelView.EnableGraphicsUpdate = false;
modulePart.SketchManager.AddToDB = true;

// keep a list of sketch points on the bottom plane
List<SketchPoint> bottomSurfaceSketchPointList = new( extrusionAxisList.Count );

// 
using (ProgressBar createBottomSurfacePointsProgressBar = new(extrusionAxisList.Count, "Creating bottom surface points", progressBarOptions))
{
    foreach (SketchSegment extrusionAxis in extrusionAxisList)
    {
        // create a point at some random location (DO NOT USE 0,0,0, that's the origin). The exact location doesn't matter since we will constraint it any ways
        SketchPoint bottomPlaneSketchPoint = modulePart.SketchManager.CreatePoint(27, 27, 27);
        bottomSurfaceSketchPointList.Add(bottomPlaneSketchPoint);

        extrusionAxis.Select4(true, swSelectData);
        MakeSelectedCoincide(ref modulePart);
        ClearSelection(ref modulePart);

        // using -1 as the mark, meaning that we don't specify the purpose of the selection to Solidworks
        ((Feature)bottomPlane).Select2(true, -1);
        bottomPlaneSketchPoint.Select4(true, swSelectData);
        MakeSelectedCoincide(ref modulePart);
        ClearSelection(ref modulePart);

        // update progress bar
        createBottomSurfacePointsProgressBar.Tick();
    }
}

modelView.EnableGraphicsUpdate = true;
modulePart.SketchManager.AddToDB = false;
// close the sketch
modulePart.Insert3DSketch();
ClearSelection(ref modulePart);

// SAVE model. In case of error, you will see error message in the console
SaveModel(SavePart, ref modulePart, Path.Join(modelOutputDirectory, $"{currentTime}_plainPizzaSlice"));

/* First, create "reference sketches". These sketches will be copied and pasted to genereate all the modules
 * 1. Find the point on the bottom plane that is the closest to the origin. 
 * 2. Use InsertRefPlane Method (IFeatureManager) on this point and the extrusion axis passing through it to create a reference plane.
 */

// find the closest element 
int closestPointIdx = GetIndexSketchPointClosestToOrigin(ref bottomSurfaceSketchPointList);
SketchPoint pointClosestToOrigin = bottomSurfaceSketchPointList[closestPointIdx];

// the primisPlane has the first created full-triangle and chamfered-triangle
RefPlane primisPlane = CreateRefPlaneFromPointAndNormal(pointClosestToOrigin, extrusionAxisList[closestPointIdx], "PrimisPlane", swSelectData, modulePart.FeatureManager);
// make the first reference plane invisible to boost performance
((Feature)primisPlane).Select2(true, -1);
modulePart.BlankRefGeom();
ClearSelection(ref modulePart);

/* Create a sketch on the newly created plane and draw a triangle on it
 */
// disable user input box for dimensions. Otherwise solidworks will stuck at waiting for user inputs
DisableInputDimensionByUser(ref solidworksApp);
modulePart.SketchManager.AddToDB = true;

// Create a new sketch on a close-to-bottom plane
((Feature)primisPlane).Select2(false, -1);
modulePart.SketchManager.InsertSketch(true);

// define where the top vertix of the equilateral triangle is. 
// 0.577350269 is sqrt(3)/3
SketchPoint firstBottomSurfaceSketchPoint = bottomSurfaceSketchPointList[closestPointIdx];
Point3D topVertixTriangle = new(firstBottomSurfaceSketchPoint.X, firstBottomSurfaceSketchPoint.Y + 0.577350269 * equilateralTriangleSideLength, firstBottomSurfaceSketchPoint.Z);
object[] unchamferedTrianglePolygon = (object[])modulePart.SketchManager.CreatePolygon(firstBottomSurfaceSketchPoint.X, firstBottomSurfaceSketchPoint.Y, firstBottomSurfaceSketchPoint.Z,
                                                                            topVertixTriangle.x, topVertixTriangle.y, topVertixTriangle.z, 3, true);

ClearSelection(ref modulePart);

// constraint the center of the triangle to the extrusion axis
SketchPoint? triangleCenter = GetTriangleCenterPoint(ref unchamferedTrianglePolygon);
if (triangleCenter != null)
{
    ClearSelection(ref modulePart);
    triangleCenter.Select4(true, swSelectData);
    firstBottomSurfaceSketchPoint.Select4(true, swSelectData);
    MakeSelectedCoincide(ref  modulePart);
    ClearSelection(ref modulePart);
}

// make one of the sides horizontal - not sure if this is the best thing to do
SketchLine? oneSideOfTriangle = GetMostHorizontalTriangleSide(ref unchamferedTrianglePolygon);
if (oneSideOfTriangle != null)
{
    ClearSelection(ref modulePart);
    ((SketchSegment)oneSideOfTriangle).Select4(true, swSelectData);
    // DEBUG: add horizontal constraint on this side - maybe fine
    MakeSelectedLineHorizontal(ref modulePart);
    // Dimension the equilateral triangle's side length
    AddDimensionToSelectedWithGlobalVariable(ref modulePart, 
                                                nameof(equilateralTriangleSideLength), 
                                                firstBottomSurfaceSketchPoint.X, 
                                                firstBottomSurfaceSketchPoint.Y, 
                                                firstBottomSurfaceSketchPoint.Z);
    ClearSelection(ref modulePart);
}

// TODO: add chamfers using global variables
MakeChamferedTriangleFromTrianglePolygon(unchamferedTrianglePolygon, chamferLength, ref modulePart, swSelectData);
ClearSelection(ref modulePart);

// DEBUG: remember the name of the chamfered sketch
((Feature)modulePart.SketchManager.ActiveSketch).Name = "Chamfered Triangle Sketch";
string chamferedSketchName = GetActiveSketchName(ref modulePart);
// close chamfered triangle sketch
modulePart.SketchManager.InsertSketch(true);
ClearSelection(ref modulePart);

// Create a sketch on the same close-to-bottom plane for the full triangle
((Feature)primisPlane).Select2(true, -1);
modulePart.SketchManager.InsertSketch(true);

///// Done with the first chamfered triangle sketch. Now create the full triangle sketch /////
object[] fullTrianglePolygon = (object[])modulePart.SketchManager.CreatePolygon(firstBottomSurfaceSketchPoint.X, firstBottomSurfaceSketchPoint.Y, firstBottomSurfaceSketchPoint.Z,
                                                                            topVertixTriangle.x, topVertixTriangle.y, topVertixTriangle.z, 3, true);
// dimension the sides
SketchLine? oneSideOfFullTriangle = GetOneTriangleSide(ref fullTrianglePolygon);
if (oneSideOfFullTriangle != null)
{
    ClearSelection(ref modulePart);
    ((SketchSegment)oneSideOfFullTriangle).Select4(true, swSelectData);
    // Dimension the equilateral triangle's side length
    AddDimensionToSelectedWithGlobalVariable(ref modulePart, 
                                                nameof(equilateralTriangleSideLength),
                                                firstBottomSurfaceSketchPoint.X, 
                                                firstBottomSurfaceSketchPoint.Y, 
                                                firstBottomSurfaceSketchPoint.Z);
    ClearSelection(ref modulePart);
}
ClearSelection(ref modulePart);

// constraint the center of the full triangle to the extrusion axis
SketchPoint? fullTriangleCenter = GetTriangleCenterPoint(ref fullTrianglePolygon);
if (fullTriangleCenter != null)
{
    fullTriangleCenter.Select4(true, swSelectData);
    firstBottomSurfaceSketchPoint.Select4(true, swSelectData);
    MakeSelectedCoincide(ref modulePart);
    ClearSelection(ref modulePart);
}

List<SketchPoint> verticesInFullTriangle = GetVerticesInTriangle(ref fullTrianglePolygon);
verticesInFullTriangle.ForEach(vertex =>
{
    vertex.Select4(true, swSelectData);
    SketchSegment addedFillet = modulePart.SketchManager.CreateFillet(filletRadiusFullTriangle, (int)swConstrainedCornerAction_e.swConstrainedCornerKeepGeometry);
    ClearSelection(ref modulePart);
});

// Give the first full triangle sketch a special name. 
((Feature)modulePart.SketchManager.ActiveSketch).Name = "Full Triangle Sketch";
string fullTriangleSketchName = ((Feature)modulePart.SketchManager.ActiveSketch).Name;
// quit editing sketch
modulePart.SketchManager.InsertSketch(true);
ClearSelection(ref modulePart);

/// In progress Create a sketch for the 3 pin holes ///
((Feature)primisPlane).Select2(true, -1);
modulePart.SketchManager.InsertSketch(true);
///// Done with the first full triangle sketch. Now create the pin hole triangle sketch /////
object[] pinHoleConstructionTriangle = (object[])modulePart.SketchManager.CreatePolygon(firstBottomSurfaceSketchPoint.X, firstBottomSurfaceSketchPoint.Y, firstBottomSurfaceSketchPoint.Z,
                                                                            topVertixTriangle.x, topVertixTriangle.y, topVertixTriangle.z, 3, true);
// Since the whole pin hole triangle is selected, we can directly call the API to make all of it as construction geometries
modulePart.SketchManager.CreateConstructionGeometry();
// dimension the sides
SketchLine? oneSideOfPinHoleTriangle = GetOneTriangleSide(ref pinHoleConstructionTriangle);
if (oneSideOfPinHoleTriangle != null)
{
    ClearSelection(ref modulePart);
    ((SketchSegment)oneSideOfPinHoleTriangle).Select4(true, swSelectData);
    // Dimension the equilateral triangle's side length
    AddDimensionToSelectedWithGlobalVariable(ref modulePart, nameof(interPinHoleDistance),
                                                firstBottomSurfaceSketchPoint.X, 
                                                firstBottomSurfaceSketchPoint.Y, 
                                                firstBottomSurfaceSketchPoint.Z);
    ClearSelection(ref modulePart);
}
// Add the pin holes on 3 vertices
// first find the vertices in a pin hole triangle
List<SketchPoint> verticesInPinHoleTriangle = GetVerticesInTriangle(ref pinHoleConstructionTriangle);
// add pin hole at every vertex
verticesInPinHoleTriangle.ForEach(vertex =>
{
    SketchSegment? pinHole = modulePart.SketchManager.CreateCircleByRadius(vertex.X, vertex.Y, 0, pinHoleDiameter);
    // dimension the pin hole's diammeter
    pinHole.Select4(true, swSelectData);
    // dimension the diammeter

    AddDimensionToSelectedWithGlobalVariable(ref modulePart, nameof(pinHoleDiameter), vertex.X, vertex.Y, vertex.Z);
    ClearSelection(ref modulePart);
});

// coincide the center point of the pin hole triangle to the extrusion axis
SketchPoint? pinHoleTriangleCenterPoint = GetTriangleCenterPoint(ref pinHoleConstructionTriangle);
if (pinHoleTriangleCenterPoint != null)
{
    pinHoleTriangleCenterPoint.Select4(true, swSelectData);
    firstBottomSurfaceSketchPoint.Select4(true, swSelectData);
    MakeSelectedCoincide(ref modulePart);
    ClearSelection(ref modulePart);
}

// Give the first pin hole triangle sketch a special name. 
((Feature)modulePart.SketchManager.ActiveSketch).Name = "Pin Hole Triangle Sketch";
string pinHoleTriangleSketchName = ((Feature)modulePart.SketchManager.ActiveSketch).Name;
// quit editing sketch
modulePart.SketchManager.InsertSketch(true);
ClearSelection(ref modulePart);

// use for loop to create triangle modules with the right shape for all the modules

// try to gain speed by locking the user interface
modelView.EnableGraphicsUpdate = true; // This property affects whether to refresh the model view during a selection
modulePart.SketchManager.DisplayWhenAdded = true;
// try the magic disable feature manager scroll to view to hopefully boost performance
solidworksApp.SetUserPreferenceToggle((int)swUserPreferenceToggle_e.swFeatureManagerEnsureVisible, false);
// try to gain speed by locking the user interface
//modulePart.Lock();
// NOTE: Start module extrusions
using (ProgressBar extrudeModulesProgressBar = new(bottomSurfaceSketchPointList.Count, "Extruding modules", progressBarOptions))
{
    for (int moduleIndex = 0; moduleIndex < bottomSurfaceSketchPointList.Count; moduleIndex++)
    {
        // skip the point closest to the origin
        if (moduleIndex == closestPointIdx) 
        {
            continue;
        };

        // save the orientation flag.
        bool isUpright = frontGridPointCloud.moduleOrientations[moduleIndex];

        // Create another test plane near the bottom and insert a sketch on it
        RefPlane aRefPlane = CreateRefPlaneFromPointAndNormal(bottomSurfaceSketchPointList[moduleIndex], extrusionAxisList[moduleIndex],
                                                                $"ModulePlane_{moduleIndex}", swSelectData, modulePart.FeatureManager);
        // hide the reference plane to avoid slowing down sketch creation
        ((Feature)aRefPlane).Select2(true, -1);
        modulePart.BlankRefGeom();
        ClearSelection(ref modulePart);

        //DEBUG:
        Debug.WriteLine($"Number of features Precopy chamfered sketch: {GetFeatureCount(ref modulePart)}");

        // copy the chamfered triangle sketch //
        (Sketch pastedChamferedTriangleSketch, SketchPoint chamferedTriangleCenter, SketchLine aLongSideChamferedTriangle) = CreateChamferedTriangleSketchFromReferenceSketch(
                                                                                                                                                ref modulePart,
                                                                                                                                                aRefPlane,
                                                                                                                                                swSelectData,
                                                                                                                                                chamferedSketchName,
                                                                                                                                                isUpright,
                                                                                                                                                bottomSurfaceSketchPointList[moduleIndex]);

        ClearSelection(ref modulePart);
        // extrude the chamfered triangle
        SelectSketch(ref modulePart, ((Feature)pastedChamferedTriangleSketch).Name);
        Feature chamferedExtrusion = CreateTwoWayExtrusion(ref modulePart);
        chamferedExtrusion.Name = $"chamferedExtrusion_{moduleIndex}";
        ClearSelection(ref modulePart);

        /// Now make the unchamfered/full triangle extrusion ///
        //DEBUG:
        Debug.WriteLine($"Number of features Precopy full tri sketch: {GetFeatureCount(ref modulePart)}");

        // copy the full triangle sketch //
        (Sketch pastedFullTriangleSketch, SketchPoint pastedFullTriangleCenter, SketchSegment aLongSideFullTriangle) = CreateFullTriangleSketchFromReferenceSketch(
                                                                                                                                ref modulePart,
                                                                                                                                aRefPlane,
                                                                                                                                swSelectData,
                                                                                                                                fullTriangleSketchName,
                                                                                                                                isUpright,
                                                                                                                                bottomSurfaceSketchPointList[moduleIndex],
                                                                                                                                (SketchSegment)aLongSideChamferedTriangle);
        ClearSelection(ref modulePart);

        // extrude the full triangle all the way to the "support surface point"
        SelectSketch(ref modulePart, ((Feature)pastedFullTriangleSketch).Name);
        Feature fullTriangleExtrusion = CreateTwoWayExtrusionD1ThroughAllD2ToPoint(ref modulePart, supportSurfaceMarkerPointList[moduleIndex], swSelectData);
        fullTriangleExtrusion.Name = $"fullTriangleExtrusion_{moduleIndex}";
        ClearSelection(ref modulePart);

        //DEBUG:
        Debug.WriteLine($"Number of features Precopy pin hole sketch: {GetFeatureCount(ref modulePart)}");

        /// Make pin holes - first test seems fine! ///        
        Sketch lastPinHoleTriangleSketch = CreatePinHoleSketchFromReferenceSketch(  ref modulePart, 
                                                                                    aRefPlane, 
                                                                                    swSelectData, 
                                                                                    pinHoleTriangleSketchName,
                                                                                    isUpright, 
                                                                                    bottomSurfaceSketchPointList[moduleIndex],
                                                                                    aLongSideFullTriangle);
        ClearSelection(ref modulePart);

        // extrude the pin holes
        double extrusionDepth = GetDistanceBetweenTwoSketchPoints(  supportSurfaceMarkerPointList[moduleIndex], 
                                                                    bottomSurfaceSketchPointList[moduleIndex])
                                                                    + pinHoleDepth;

        Debug.WriteLine($"Extrusion depth at module {moduleIndex} is {extrusionDepth, 0:F3} meters");

        SelectSketch(ref modulePart, ((Feature)lastPinHoleTriangleSketch).Name);
        Feature pinHoleExtrusion = CreateTwoWayExtrusionD1ThroughAllD2ToDistance(ref modulePart, extrusionDepth);
        if (pinHoleExtrusion == null)
        {
            Console.WriteLine($"Failed to extrude pin hole {moduleIndex}");
        }
        pinHoleExtrusion.Name = $"pinHoleExtrusion_{moduleIndex}";
        ClearSelection(ref modulePart);

        // DEBUG: try rebuilding everything at the end of pasting all the triangles
        bool rebuildSuccess = modulePart.EditRebuild3();
        string rebuildStatus = rebuildSuccess switch
        {
            true => "success",
            false => "failed",
        };
        Debug.WriteLine($"Rebuild modules{moduleIndex} {rebuildStatus}");

        // update progress bar
        extrudeModulesProgressBar.Tick();
    }
}

// TODO: finally extrude the "reference sketches"

//modulePart.UnLock();
solidworksApp.SetUserPreferenceToggle((int)swUserPreferenceToggle_e.swFeatureManagerEnsureVisible, true);
modelView.EnableGraphicsUpdate = true;
modulePart.SketchManager.DisplayWhenAdded = true;
modulePart.SketchManager.AddToDB = false;

// enbale user input box for dimensions
EnableInputDimensionByUser(ref solidworksApp);

// DEBUG: print the feature tree
PrintFeaturesInFeatureManagerDesignTree(ref modulePart);

Console.WriteLine("Module extrusions completed");
SaveModel(SavePart, ref modulePart, Path.Join(modelOutputDirectory, $"{currentTime}_FocalPlate_{project}"));

// wait for user input before closing
PromptAndWait("Press any key to close Solidworks");
// close Solidworks that runs in the background
solidworksApp.ExitApp();